# -*- coding: utf-8 -*-
"""project_grpcloud

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1txZlonu-EgJlSbxdbtKxeIxta-CjJFDv
"""

# Commented out IPython magic to ensure Python compatibility.
#Basic Library
import pandas as pd
import numpy as np

#Visualization libraries
import matplotlib.pyplot as plt
from matplotlib.ticker import FormatStrFormatter
import seaborn as sns
import warnings

import folium
from IPython.display import HTML
# %matplotlib inline
import plotly.express as px
import plotly.graph_objs as go
from plotly import tools
from plotly.offline import iplot

df=pd.read_csv("onlinedeliverydata (1).csv")

df.head()

"""We can understand here more categorical variables and very less continuous variables"""

df.info()

df.describe()

"""we have a 388 respondents in the dataset

Age between 18-33 with an average of 25

Total family size of  the records between 1-6 and average of 3


"""

df.isnull().sum()

df.shape

df.columns

df["Monthly Income"].value_counts()

for i in range(388):
    if df["Monthly Income"].values[i] == "No Income":
        df["Monthly Income"].values[i] = 0
    elif df["Monthly Income"].values[i] == "Below Rs.10000":
        df["Monthly Income"].values[i] = 5000
    elif df["Monthly Income"].values[i] == "10001 to 25000":
        df["Monthly Income"].values[i] = 15000
    elif df["Monthly Income"].values[i] == "25001 to 50000":
        df["Monthly Income"].values[i] = 30000
    elif df["Monthly Income"].values[i] == "More than 50000":
        df["Monthly Income"].values[i] = 60000        
df.head(11)

df["Gender"].value_counts()

#
#Categorical Variables
plt.figure(1)
plt.subplot(221)
df['Gender'].value_counts().plot.pie(title=' Gender',figsize=(20,10),autopct="%1.1f",explode=[0,.1])
plt.subplot(222)
df['Marital Status'].value_counts().plot.pie(title='Marital Status',cmap="Accent",autopct="%1.1f%%",explode=[0,0,0.1])
plt.subplot(223)
df['Occupation'].value_counts().plot.pie(title='Occupation',cmap="Accent",autopct="%1.1f%%",explode=[0,0,0,0.2])
plt.subplot(224)
df['Educational Qualifications'].value_counts().plot.pie(title=' Education',cmap="Accent",autopct="%1.1f%%",explode=[0,0,0,0,0.3])

"""
A) 57% of the respndents are the male and 43% are female. 

B) Respondents' education was highest in that  young graduates (46%)  and graduate students (44%), includes doctoral students, school children, and uneducated people.

C)Respondents' marriage status was high from singles (69%)

D)The occupation of respondents where highly from the student (54%)"""

# Commented out IPython magic to ensure Python compatibility.
#Data Visualization

# %matplotlib inline

_ = [0, 6]
_ = list(enumerate([list(df.columns)[i] for i in _], start=1))

fig = plt.figure(figsize=[16,24])
for index, col_name in _:
    ax = fig.add_subplot(3, 1, index)    
    sns.countplot(x=col_name, data=df, hue='Output', palette='inferno')

"""You can also see that the reorganization is taking place in the age group under 25 and families under 4 years. Occurs more frequently"""

#Income Countplot
plt.subplot(1,1,1)
ax = sns.countplot(x="Monthly Income", data=df,
                   facecolor=(0, 0, 0, 0),
                   linewidth=5,
                   edgecolor=sns.color_palette("dark", 3))
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=20)
ax.set_title('Monthly Income count',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count_Income', fontsize = 12)
plt.tight_layout()

"""Most of the respondents  are students they don't have a stable income, so they fall into the non-income category that supports age variables. The next highest income group was between Rs 25001 and Rs 50,000, which was the nominal salary  new entrants to the corporate industry. In terms of profession, the data shows more student respondents supporting previous analyzes, followed by employee respondents. The data also includes self-employed and housewife respondents. Most of the respondents have bachelor's degree, and the number of married people is very lower."""

#Family Size Countplot
plt.subplot(1,1,1)
ax = sns.countplot(x="Family size", data=df,
                   facecolor=(0, 0, 0, 0),
                   linewidth=5,
                   edgecolor=sns.color_palette("dark", 3))
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=20)
ax.set_title('Family size',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count_Size', fontsize = 12)
plt.tight_layout()

"""A family distribution where the majority of the recorded family size (the number of people living with you) is three, followed by the second food in their room."""

#Meal Countplot
plt.subplot(1,3,1)
ax = sns.countplot(x="Meal(P1)", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11)
ax.set_title('Meal count',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count_Meal', fontsize = 12)
plt.tight_layout()

#Medium Countplot
plt.subplot(1,3,2)
ax = sns.countplot(x="Medium (P1)", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11)
ax.set_title('Medium Status count',fontsize = 15)
ax.set_xlabel('Types',fontsize = 15) 
ax.set_ylabel('Count_Medium', fontsize = 12)
plt.tight_layout()

#Preference Countplot
plt.subplot(1,3,3)
ax = sns.countplot(x="Perference(P1)", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=20)
ax.set_title('Preference count',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count_Preference', fontsize = 12)
plt.tight_layout()

"""You can watch the data of the consumer preferences, meals of the day,  meal types, and media for purchasing food. Most preferences are grocery delivery applications when it comes to shopping media, followed by walking, with few  direct phone or web browser numbers. Non-veg is the most preferred type of food, and also vegetarian foods, followed by minimal sweets and baked goods."""

#Setting up the frame
plt.figure(figsize = (15, 7))
plt.style.use('ggplot')

#Ease and convenient Countplot
plt.subplot(2,4,1)
ax = sns.countplot(x="Ease and convenient", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Ease and convenient',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Time Countplot
plt.subplot(2,4,2)
ax = sns.countplot(x="Time saving", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Time saving',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Restaurant Countplot
plt.subplot(2,4,3)
ax = sns.countplot(x="More restaurant choices", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('More restaurant choices',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Payment Countplot
plt.subplot(2,4,4)
ax = sns.countplot(x="Easy Payment option", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Easy Payment option',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Offers Countplot
plt.subplot(2,4,5)
ax = sns.countplot(x="More Offers and Discount", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('More Offers and Discount',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Preference Countplot
plt.subplot(2,4,6)
ax = sns.countplot(x="Good Food quality", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Good Food quality',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count_Preference', fontsize = 12)
plt.tight_layout()

#Tracking Countplot
plt.subplot(2,4,7)
ax = sns.countplot(x="Good Tracking system", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Good Tracking system',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

"""You can identify the demand factors that goes consumers to buy orders from your application. You can see the simplicity and convenience of ordering using the app is very much in agree with the impact on your order. Around 258 respondents agreed that ordering using the application can save time, so the time-saving thing was also the biggest answer. Respondents agree that they can also place an order based on the restaurant selection specified in the application. Payment also makes an important thing, as 143 respondents agreed to consider this factor in their order inquiries. The majority of  respondents agree that the amount of food they receive also affects in turn, but  nearly 112 respondents  are neutral to this, and tracking systems are viable, if any. For example, he points out that  it is really well designed. Shop through the grocery delivery app."""

#Setting up the frame
plt.figure(figsize = (15, 7))
plt.style.use('ggplot')
#Long delivery time Countplot
plt.subplot(2,3,1)
ax = sns.countplot(x="Long delivery time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Long delivery time',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Delay of delivery person getting assigned Countplot
plt.subplot(2,3,2)
ax = sns.countplot(x="Delay of delivery person getting assigned", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Delay of delivery person getting assigned',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Delay of delivery person picking up food Countplot
plt.subplot(2,3,3)
ax = sns.countplot(x="Delay of delivery person picking up food", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Delay of delivery person picking up food',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Wrong order delivered Countplot
plt.subplot(2,3,4)
ax = sns.countplot(x="Wrong order delivered", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Wrong order delivered',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Missing item Countplot
plt.subplot(2,3,5)
ax = sns.countplot(x="Missing item", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Missing item',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Order placed by mistake Countplot
plt.subplot(2,3,6)
ax = sns.countplot(x="Order placed by mistake", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Order placed by mistake',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count_Preference', fontsize = 12)
plt.tight_layout()

"""People feel that long  delivery times have a high impact on canceling current orders. You also agree that delays in the allocation of delivery personnel and delays in the collection of food will be added to  the decision to cancel the order. The majority of respondents, on the other hand, recognize the problem as soon as the order is delivered and cannot cancel it at that point, so they do not cancel the order because they delivered the missing or incorrect item.

"""



#Setting up the frame
plt.figure(figsize = (15, 7))
plt.style.use('bmh')

#Influence of time Countplot
plt.subplot(2,4,1)
ax = sns.countplot(x="Influence of time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Influence of time',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Order Time Countplot
plt.subplot(2,4,2)
ax = sns.countplot(x="Order Time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Order Time',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Maximum wait time Countplot
plt.subplot(2,4,3)
ax = sns.countplot(x="Maximum wait time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Maximum wait time',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Hygiene Countplot
plt.subplot(2,4,4)
ax = sns.countplot(x="Residence in busy location", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Residence in busy location',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Accuracy Countplot
plt.subplot(2,4,5)
ax = sns.countplot(x="Google Maps Accuracy", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Google Maps Accuracy',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()
#Good Road Condition Countplot
plt.subplot(2,4,6)
ax = sns.countplot(x="Good Road Condition", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Good Road Condition',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Low quantity low time Countplot
plt.subplot(2,4,7)
ax = sns.countplot(x="Low quantity low time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Low quantity low time',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Delivery person ability Countplot
plt.subplot(2,4,8)
ax = sns.countplot(x="Delivery person ability", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Delivery person ability',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

"""The majority of respondents agree that their order affects the time of the entire process. Nearly 269 respondents said they placed orders anytime on weekdays and  the next highest orders on weekends and weekdays. Respondents also say's that the majority had a maximum waiting time of 45 minutes, with 30 and 60 minutes being accurate before receiving an order thereafter. Nearly 169 people feel that if they order a small amount, the cooking time will be short and the order will arrive sooner. Many Bangalore residents now feel that  the road conditions are good. The majority also believe that it is up to the courier to find the location and deliver the order as soon as possible."""

#Setting up the frame
plt.figure(figsize = (15, 7))
plt.style.use('bmh')

#Influence of rating Countplot
plt.subplot(2,5,1)
ax = sns.countplot(x="Influence of rating", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Influence of rating',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Less Delivery time Countplot
plt.subplot(2,5,2)
ax = sns.countplot(x="Less Delivery time", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Less Delivery time',fontsize = 15)
ax.set_xlabel('Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#High Quality of package Countplot
plt.subplot(2,5,3)
ax = sns.countplot(x="High Quality of package", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('High Quality of package',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Politeness Countplot
plt.subplot(2,5,4)
ax = sns.countplot(x="Politeness", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Politeness',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()


#Number of calls Countplot
plt.subplot(2,5,5)
ax = sns.countplot(x="Number of calls", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Number of calls',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Freshness Countplot
plt.subplot(2,5,6)
ax = sns.countplot(x="Freshness ", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Freshness',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Temperature Countplot
plt.subplot(2,5,7)
ax = sns.countplot(x="Temperature", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Temperature',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Good Taste Contplot
plt.subplot(2,5,8)
ax = sns.countplot(x="Good Taste ", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Good Taste',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

#Good Quantity Countplot
plt.subplot(2,5,9)
ax = sns.countplot(x="Good Quantity", data=df)
ax.set_xticklabels(ax.get_xticklabels(), fontsize=11,rotation=40)
ax.set_title('Good Quantity',fontsize = 15)
ax.set_xlabel( 'Types',fontsize = 12) 
ax.set_ylabel('Count', fontsize = 12)
plt.tight_layout()

"""Nearly 286 respondents  agreed  that the majority of  people thinks package quality to be important in  delivery. Shortening the  delivery time is also an important factor in the evaluation. When it comes to courier, the  majority of respondents thinks the number of calls  and politeness to be important factors. Delivery personnel usually call more often if there is a problem and are not polite if they find the delivery process difficult, which reflects their assessment. The majority of them are positive and consider all  factors to be important in assessing a restaurant.Looking at each photo, we can see that the majority of  people consider freshness to be a very important factor when it comes to rating. They also consider temperature to be an important factor, but not so important because customers can understand that the food is  delivered in the same period. Many consumers consider good quantity and  taste to be very vital factors."""



df.head()

pip install datacleaner

#this library i found on google it's helpful for cleaning data,imputing value and lable encoding
import  datacleaner as dc # pip install datacleaner

dc.autoclean(df).head()

df.shape

df.drop(['latitude', 'longitude', 'Pin code','Medium (P1)', 'Medium (P2)', 'Meal(P1)', 'Meal(P2)'], axis=1, inplace=True)

X = df.drop('Output', axis=1) # input categorical features
y = df.Output

X.shape, df.shape

X.head()

# Train Test Split 
df_train = df.copy()
df_train.shape
train = df_train.drop(["Output"],axis=1)
train_ = df_train["Output"]

X_train = train.values
y_train = train_.values

#Feature Scaling 
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)

from sklearn.model_selection import train_test_split, cross_val_predict,cross_validate
train_x, test_x,train_y,test_y = train_test_split(X_train,y_train,test_size  = 0.2, random_state=0)
print("Train dataset shape: {0}, \nTest dataset shape: {1}".format(train_x.shape, test_x.shape))

#library import for model

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix, classification_report, precision_score, recall_score, accuracy_score

# Logistic Regression

logistic = LogisticRegression(max_iter=10000)
#fitting the values for x and y
logistic.fit(train_x,train_y)

#predictions from test data
prediction = logistic.predict(test_x)	
#print(prediction)

#calculating the accuracy
accuracy_score = accuracy_score(test_y,prediction)
print("Accuracy Score Logistic Regresion  :",accuracy_score)



"""So our predictions are almost 83% accurate, i.e. we have identified 83% of the output correctly for our logistic regression model."""

###### confusion matrix  starts ######
from sklearn.metrics import accuracy_score, confusion_matrix
cm_lgr1 = confusion_matrix(test_y,prediction) 
names = np.unique(prediction)
sns.heatmap(cm_lgr1, square=True, annot=True, cbar=False,xticklabels=names, yticklabels=names, cmap="YlGnBu" ,fmt='g')
plt.xlabel('Truth')
plt.ylabel('Predicted')

"""Total 6 misclassified out of 78 test values."""

#Decision Tree
from sklearn.tree import DecisionTreeClassifier
tree_model = DecisionTreeClassifier(random_state=1)
tree_model.fit(train_x,train_y)
pred_cv_tree=tree_model.predict(test_x)
score_tree =accuracy_score(pred_cv_tree,test_y)*100 
score_tree

"""our predictions are almost 75.6% accurate, i.e. we have identified 75.6% of the Output status correctly for our Decision tree model"""

#random forest 
from sklearn.ensemble import RandomForestClassifier
forest_model = RandomForestClassifier(random_state=1,max_depth=10,n_estimators=50)
forest_model.fit(train_x,train_y)
pred_cv_forest=forest_model.predict(test_x)
score_forest = accuracy_score(pred_cv_forest,test_y)*100
score_forest

"""our predictions are almost 89.7% accurate, i.e. we have identified 89.7% of the Output status correctly for our Random Forest model."""

#KNN
from sklearn.neighbors import KNeighborsClassifier
knn_model =  KNeighborsClassifier(n_neighbors=3)
knn_model.fit(train_x,train_y)
pred_cv_knn=knn_model.predict(test_x)
score_knn = accuracy_score(pred_cv_knn,test_y)*100
score_knn

"""our predictions are almost 83.3% accurate, i.e. we have identified 83.3% of the Output status correctly for our KNeighbors Classifier."""

#Naive Bayes
from sklearn.naive_bayes import GaussianNB
gnb_model = GaussianNB()
gnb_model.fit(train_x,train_y)
pred_cv_gnb=knn_model.predict(test_x)
score_gnb = accuracy_score(pred_cv_gnb,test_y)*100
score_gnb

"""our predictions are almost 83.3% accurate, i.e. we have identified 83.3% of the Output status correctly for our Naive Bayes.

Logistic Regression model gives : 83.3% prediction accuracy

Decision Tree model gives : 75.6% prediction accuracy

Random Forest model gives : 89.7% prediction accuracy

kNNClassifier model gives : 83.3% prediction accuracy

Naive Bayes Classifier model gives : 83.3% prediction accuracy
"""

importances = pd.Series(forest_model.feature_importances_,index=X.columns)
importances.plot(kind='barh', figsize=(12,8))

"""we can find out that ease and conventient and Review feature are most important. So, feature engineering helped us in predicting our target variable.

Conclusion
Conclusion- After testing 6 different algorithms, the best accuracy on the board is achieved by RandomForest (89.7%)followed by Logistic Regression , KNNClassifier model andNaive Bayes Classifie is equal accuracy 83.3% and Decision Tree performed the worst (75.6%).

The orders is heavily dependent on the ease and convenient or reivew for Predictions.

The RandomForest model algorithm gives us the maximum Accuracy (89.7) % compared to the other 3 Machine Learning Classification Algorithms.
"""

